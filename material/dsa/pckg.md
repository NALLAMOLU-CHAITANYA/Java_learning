**7.5 to 10**:
1. **Arrays**: Collection of elements with indices.
2. **Strings**: Sequence of characters, manipulation.
3. **LinkedList**: Linear structure, nodes with pointers.
4. **Stacks**: LIFO, push and pop operations.
5. **Queues**: FIFO, enqueue and dequeue operations.
6. **Hashing**: Efficient key-value pair mapping.
7. **Sorting**: Arranging data in order.
8. **Searching**: Finding elements in data structures.
9. **Recursion**: Function calling itself to solve problems.

**10 to 25**:
1. **DP** : solving problems using overlapping
2. **Trees**
3. **graphs** : vertices connected by edges, traversal.
4. **Heaps**: complete BT for priority queues
5. **Greedy**: Making optimal choices at each step.
6. **Backtracking**:  finding solutions white trail and error
7. **Tries**: Tree for sorting strings fast search
8. **Segment trees**: efficient range queries and updates

**25 to 50**:
1.	**Advanced DP**: optimising dynamic programming with constraints
2.	**graph algorithms**: shortest path, minimum spanning tree
3.	**balanced trees**: self balancing trees for fast search
4.	**greedy advanced**: solving complex greedy problems efficiently
5.	**string matching**: searching for patterns in strings
6.	**bit manipulation**: effectively manipulating binary numbers
7.	**geometry**: algorithms for geometric problem solving.


**50 and above**:
1.	**Flow algorithms**: optimising network flow and connectivity
2.	**Parallel algorithms**: leveraging multiple processors
3.	**splay trees**: self adjusting binary search trees
4.	**distributed**: systems across multiple machines for scalability
5.	**ml algorithms**: machine learning algorithms for predictions. Will not
